import { ChannelData } from '../models/types/channel-data';
import { ChannelInfo } from '../models/types/channel-info';
import { ClientConfig } from '../models/types/clientConfig';
import { AddChannelLogBody, CreateChannelBody, CreateChannelResponse, ReimportBody, ValidateBody, ValidateResponse } from '../models/types/request-response-bodies';
import { Base } from './base';
export declare class Channel extends Base {
    constructor(config: ClientConfig);
    /**
     * Create a new channel. An author can create a new channel with specific topics where other clients can subscribe to.
     * @param data
     * @returns
     */
    create(data: CreateChannelBody): Promise<CreateChannelResponse>;
    /**
     * Write data to a channel with address channel address. Write permission is mandatory. The type and metadata fields are not encrypted to have a possibility to search for events. The payload is stored encrypted for encrypted channels.
     * @param address
     * @param data
     * @returns
     */
    write(address: string, data: AddChannelLogBody): Promise<ChannelData>;
    /**
     * Get data from the channel with address channel address. The first possible message a subscriber can receive is the time the subscription got approved all messages before are not received. Read permission is mandatory.
     * @param address
     * @param limit
     * @param index
     * @param asc
     * @param startDate
     * @param endDate
     * @returns
     */
    read(address: string, limit?: number, index?: number, asc?: boolean, startDate?: Date, endDate?: Date): Promise<ChannelData[]>;
    /**
     * Get all data of a channel using a shared key (in case of encrypted channels). Mainly used from auditors to evaluate a log stream.
     * @param address
     * @param presharedKey
     * @returns
     */
    readHistory(address: string, presharedKey: string): Promise<ChannelData[]>;
    /**
     * Validates channel data by comparing the log of each link with the data on the tangle.
     * @param address
     * @param data
     * @returns
     */
    validate(address: string, data: ValidateBody): Promise<ValidateResponse>;
    /**
     * The user can decide to re-import the data from the Tangle into the database. A reason for it could be a malicious state of the data.
     * @param address
     * @param data
     * @returns
     */
    reimport(address: string, data: ReimportBody): Promise<null>;
    /**
     * Search for a channel. A client can search for a channel which it is interested in.
     * @param author
     * @param topicType
     * @param topicSource
     * @param created
     * @param latestMessage
     * @param limit
     * @param index
     * @returns
     */
    search(author?: string, topicType?: string, topicSource?: string, created?: Date, latestMessage?: Date, limit?: number, index?: number): Promise<ChannelInfo[]>;
    /**
     * Get information about a channel with address channel-address.
     * @param address
     * @returns
     */
    info(address: string): Promise<ChannelInfo>;
    /**
     * Add an existing channel into the database. Clients are able to add existing channels into the database so others can subscribe to them. This will be automatically called when a channel will be created.
     * @param channel
     * @returns
     */
    add(channel: ChannelInfo): Promise<null>;
    /**
     * Update channel information. The author of a channel can update topics of a channel.
     * @param channel
     * @returns
     */
    update(channel: ChannelInfo): Promise<null>;
    /**
     * Delete information of a channel with address channel-address. The author of a channel can delete its entry in the database. In this case all subscriptions will be deleted and the channel won’t be found in the system anymore. The data & channel won’t be deleted from the IOTA Tangle since its data is immutable on the tangle!
     * @param address
     * @returns
     */
    remove(address: string): Promise<null>;
}
//# sourceMappingURL=channel.d.ts.map