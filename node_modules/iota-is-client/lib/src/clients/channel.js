"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Channel = void 0;
const base_1 = require("./base");
class Channel extends base_1.Base {
    constructor(config) {
        super(config);
    }
    /**
     * Create a new channel. An author can create a new channel with specific topics where other clients can subscribe to.
     * @param data
     * @returns
     */
    create(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post('channels/create', data, base_1.Base.jwtToken);
        });
    }
    /**
     * Write data to a channel with address channel address. Write permission is mandatory. The type and metadata fields are not encrypted to have a possibility to search for events. The payload is stored encrypted for encrypted channels.
     * @param address
     * @param data
     * @returns
     */
    write(address, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`channels/logs/${address}`, data, base_1.Base.jwtToken);
        });
    }
    /**
     * Get data from the channel with address channel address. The first possible message a subscriber can receive is the time the subscription got approved all messages before are not received. Read permission is mandatory.
     * @param address
     * @param limit
     * @param index
     * @param asc
     * @param startDate
     * @param endDate
     * @returns
     */
    read(address, limit, index, asc = true, startDate, endDate) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`channels/logs/${address}`, { limit, index, asc, 'start-date': startDate, 'end-date': endDate }, base_1.Base.jwtToken);
        });
    }
    /**
     * Get all data of a channel using a shared key (in case of encrypted channels). Mainly used from auditors to evaluate a log stream.
     * @param address
     * @param presharedKey
     * @returns
     */
    readHistory(address, presharedKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`channels/history/${address}`, {
                'preshared-key': presharedKey,
            });
        });
    }
    /**
     * Validates channel data by comparing the log of each link with the data on the tangle.
     * @param address
     * @param data
     * @returns
     */
    validate(address, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`channels/validate/${address}`, data, base_1.Base.jwtToken);
        });
    }
    /**
     * The user can decide to re-import the data from the Tangle into the database. A reason for it could be a malicious state of the data.
     * @param address
     * @param data
     * @returns
     */
    reimport(address, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`re-import/${address}`, data, base_1.Base.jwtToken);
        });
    }
    /**
     * Search for a channel. A client can search for a channel which it is interested in.
     * @param author
     * @param topicType
     * @param topicSource
     * @param created
     * @param latestMessage
     * @param limit
     * @param index
     * @returns
     */
    search(author, topicType, topicSource, created, latestMessage, limit, index) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get('channel-info/search', {
                author,
                'topic-type': topicType,
                'topic-source': topicSource,
                created,
                'latest-message': latestMessage,
                limit,
                index,
            }, base_1.Base.jwtToken);
        });
    }
    /**
     * Get information about a channel with address channel-address.
     * @param address
     * @returns
     */
    info(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`channel-info/channel/${address}`);
        });
    }
    /**
     * Add an existing channel into the database. Clients are able to add existing channels into the database so others can subscribe to them. This will be automatically called when a channel will be created.
     * @param channel
     * @returns
     */
    add(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post('channel-info/channel', channel, base_1.Base.jwtToken);
        });
    }
    /**
     * Update channel information. The author of a channel can update topics of a channel.
     * @param channel
     * @returns
     */
    update(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.put('channel-info/channel', channel, base_1.Base.jwtToken);
        });
    }
    /**
     * Delete information of a channel with address channel-address. The author of a channel can delete its entry in the database. In this case all subscriptions will be deleted and the channel won’t be found in the system anymore. The data & channel won’t be deleted from the IOTA Tangle since its data is immutable on the tangle!
     * @param address
     * @returns
     */
    remove(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.delete(`channel-info/channel/${address}`, {}, base_1.Base.jwtToken);
        });
    }
}
exports.Channel = Channel;
//# sourceMappingURL=channel.js.map