"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subscription = void 0;
const base_1 = require("./base");
class Subscription extends base_1.Base {
    constructor(config) {
        super(config);
    }
    /**
     * Get all subscriptions of a channel. Use the is-authorized query parameter to filter for authorized subscriptions.
     * @param channelAddress
     * @param isAuthorized
     * @returns
     */
    findAll(channelAddress, isAuthorized) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = isAuthorized !== undefined ? { 'is-authorized': isAuthorized } : {};
            return yield this.get(`subscriptions/${channelAddress}`, params, this.jwtToken);
        });
    }
    /**
     * Get a subscription of a channel by identity id.
     * @param channelAddress
     * @param identityId
     * @returns
     */
    find(channelAddress, identityId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`subscriptions/${channelAddress}/${identityId}`, {}, this.jwtToken);
        });
    }
    /**
     * Request subscription to a channel with address channel-address. A client can request a subscription to a channel which it then is able to read/write from.
     * @param channelAddress
     * @param options
     * @returns
     */
    request(channelAddress, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`subscriptions/request/${channelAddress}`, options, this.jwtToken);
        });
    }
    /**
     * Authorize a subscription to a channel with address channel-address. The author of a channel can authorize a subscriber to read/write from a channel. Eventually after verifying its identity (using the Ecommerce-SSI Bridge).
     * @param channelAddress
     * @param authorization
     * @returns
     */
    authorize(channelAddress, subscriptionIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`subscriptions/authorize/${channelAddress}`, subscriptionIdentifier, this.jwtToken);
        });
    }
    /**
     * Revoke subscription to a channel. Only the author of a channel can revoke a subscription from a channel.
     * @param channelAddress
     * @param subscriptionIdentifier
     * @returns
     */
    revoke(channelAddress, subscriptionIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`subscriptions/revoke/${channelAddress}`, subscriptionIdentifier, this.jwtToken);
        });
    }
    /**
     * Adds an existing subscription (e.g. the subscription was not created with the api but locally.)
     * @param channelAddress
     * @param identityId
     * @param subscription
     * @returns
     */
    add(channelAddress, identityId, subscription) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`subscriptions/${channelAddress}/${identityId}`, subscription, this.jwtToken);
        });
    }
    /**
     * Updates an existing subscription.
     * @param channelAddress
     * @param identityId
     * @param updatedSubscription
     * @returns
     */
    update(channelAddress, identityId, updatedSubscription) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.put(`subscriptions/${channelAddress}/${identityId}`, updatedSubscription, this.jwtToken);
        });
    }
    /**
     * Deletes an existing subscription.
     * @param channelAddress
     * @param identityId
     * @returns
     */
    remove(channelAddress, identityId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.delete(`subscriptions/${channelAddress}/${identityId}`, {}, this.jwtToken);
        });
    }
}
exports.Subscription = Subscription;
//# sourceMappingURL=subscription.js.map